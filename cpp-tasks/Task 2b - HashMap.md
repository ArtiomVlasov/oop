# ФИТ НГУ, курс ООП

## Задача 1. Hash Map

Реализовать [ассоциативный массив](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2) (другие названия: map, словарь, таблица, мэпа) на основе хешей/бакетов. https://ru.wikipedia.org/wiki/Хеш-таблица

В качестве ключей и значений контейнер принимает строки (`std::string`).

Нужно реализовать **как минимум** следующие методы:

```C++
class HashMap {
public:

    // стандартный конструктор
    HashMap();

    // конструктор копирования
    HashMap(const HashMap& other_map);

    // деструктор
    ~HashMap();

    // оператор присваивания
    HashMap& operator=(const HashMap& other_map);

    // получить количество элементов
    std::size_t size() const;

    // доступ / вставка элемента по ключу
    std::string& operator[](const std::string& key);

    // возвращает true, если запись с таким ключом присутствует
    bool contains(const std::string& key);

    // удаление элемента по ключу, возвращает количество удаленных элементов (0 или 1)
    std::size_t erase(const std::string& key);

    // очистка мэпы, удаление всех элементов
    void clear();
}
```

Класс хранит записи в одном (или нескольких) массивах. **Запрещается** использовать контейнеры STL (кроме `std::string`). 
Это должны быть обычные массивы, которые вы создаете с помощью оператора `new[]` и удаляете оператором `delete[]`.

Класс обеспечивает константную сложность в лучшем случае (`O(C)`) доступа по ключу (`operator[]` в случае, когда ключ уже есть, `contains`) из за хеширования и поиска в бакете.

Сложность вставки (`operator[]` в случае, когда ключа еще нет) и удаления (`erase`) элементов - линейная.

По достижении определенного заполнения массиков таблицы должно производиться ре-хеширование.

Пример работы с этим контейнером:

```C++
HashMap student;
student["first_name"] = "Ivan";
student["last_name"] = "Petrov";
student["university"] = "NSU";
student["department"] = "FIT";
student["group"] = "...";
// ...

std::cout << "Student: " << student["first_name"] << " " << student["last_name"] << "\n";
```

### Технические требования

1. Проект должен собираться с помощью CMake. Шаблон проекта для CMake с описанием, как все настроить, см. в папке [cpp-template](../cpp-template).
2. Должны быть тесты с использованием GoogleTest. В шаблоне для CMake GoogleTest уже подключен, вам лишь нужно их написать.

## Дополнительно для автомата

Дополнительные возможности, предлагаемые для реализации тем, кто сделает основное и претендует на автомат:

1. реализовать конструктор перемещения и перемещающий `operator=`:

   ```C++
   HashMap(HashMap&& x) noexcept;
   HashMap& operator=(HashMap&& x) noexcept;
   ```

2. реализовать обход по итератору, а именно методы:

   ```C++
   // Получить итератор на первый элемент
   iterator begin();

   // Получить итератор на элемент, следующий за последним
   iterator end();

   // Получить итератор на элемент по данному ключу, или на end(), если такого ключа нет.
   // В отличие от operator[] не создает записи для этого ключа, если её ещё нет
   iterator find(const std::string& x);
   ```

   Детали реализации класса `iterator` продумайте сами. Должен работать следующий код:

   ```C++
   // выводит все пары в мэпе student в формате "ключ: значение"
   for (auto it = student.begin(); it != student.end(); ++it) {
       std::cout << it->first << ": " << it->second << "\n";
   }
   ```

3. превратить ваш класс в шаблонный класс, поддерживающий любые типы ключей (для которых определён `operator<`) и любые типы значений (для которых определён конструктор без параметров).

   ```C++
   template <class Key, class Value>
   class HashMap {
       // ...
   }
   ```
